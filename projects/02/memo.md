2019-04-17 23:13:00

# ブール算術
1章で作った論理ゲートを出発点にして算術論理演算器(ALU)を作るのがこの章の目的

ブール算術とは、
{0,1} 上の多項式算術演算のことを言う
$$
0 + 0 = 1 + 1 = 0 \\

0 + 1 = 1 + 0 = 1 \\

0 * 0 = 0 * 1 = 1 * 0 = 0 \\

1 * 1 = 1 \\
$$

* 2進数の加算は、 XOR と同じ動作をする
* 2進数の乗算は、 AND と同じ動作をする

> つまり、{0,1} 上の 2 つの多項式の加算は、ビット単位の排他的論理和 (XOR) と同じで、{0,1} 上の 2 つの多項式の乗算は、部分積が加算の代わりに排他的論理和になることを除いて、整数の乗算と同じです。
[ARM Information Center](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0473ij/CIHFHCGA.html)

## 2の補数
メモ： 補数とはある数に加えると、あらかじめ定めた一定数になるような数。例、10に対する３の補数は７。余数。

(2進数の)2の補数は、 ある数 x に y を加えると繰り上がりが生じる最小の数 y のことを指す。 具体的に言うと、 110 + y = 1000 になるような y = 10 が 110 に対する2の補数
(2進数の)1の補数は、 ある数 x に y を加えると繰り上がりになる一歩手前の数 y のことを指す。具体的に言うと 1001 + y = 1111 になるような y = 110 が 1001 に対する1の補数


$ x^- $ を２の補数表現とする
def.
$$ x^- = 2^n - x $$

例： 5bit 2進数の $-3_{10} = - 00011_2$ を考える
$$
-3 = 2^5 - 3 = 32 - 3 = 29 = 11101
$$

結果の確認は

$$
3 + (-3)= 0
$$

を利用して確認する

$$
00011 + 11101 = 100000 \\
\text{5 bit の2進演算なので}\\
100000 = 00000
$$

n bit の 2の補数表現において、

$x + (-x)$ は常に $2^{n}$ となる。 これが2の補数の名前の由来

[2の補数は分かりにくい、こう考えれば分かる - 檜山正幸のキマイラ飼育記 (はてなBlog)](http://m-hiyama.hatenablog.com/entry/20150623/1435025054)

$2^{n}$ bit の半分を正数、もう半分を負数とする。

例：
$2^{3}$ bit の場合
1~4 は正数
5~8 は負数

| 表現できる状態数 | 値 (10) semanntics | syntax(2) | 値 (2) semantics |
| ---:             | ---:               | ---:      | ---:             |
| 1                | 0                  | 000       | 0                |
| 2                | 1                  | 001       | 1                |
| 3                | 2                  | 010       | 10               |
| 4                | 3                  | 011       | 11               |
| 5                | -4                 | 100       | -100             |
| 6                | -3                 | 101       | -11              |
| 7                | -2                 | 110       | -10              |
| 8                | -1                 | 111       | -1               |

2 の補数がようやくわかった。。
表現できうる数に対して半分は正数、もう半分は負数にして考えるってことなのか。

> 固定された有限個の記号しかない状況での、表現と演算の問題
つまり、syntax と semantics を区別して考えることが大切。

8ビットにおける2進数の 110 という表現(syntax) に関して、 その値(意味)ははっきりしない。
なぜなら、二通りの意味論があるから。
正数解釈をするなら 110 は 110 だし、 負数解釈するなら、 110 は -10

2の補数表現は優秀で、
正数解釈の値同士の計算方法と正負数解釈の値同士の計算方法は同じである。
それぞれに別個のアルゴリズムを考えなくて良い。

n ビットでは $2^{n}$ の状態数を表現できる
符号付き数を考えるには、いろいろと考え方があるんだけど、 2の補数表現を考える事が多い。
半分は正の数、もう半分は負の数とする。
半分の境をどうするかだけど、負の数とするとのちのち楽になるのでそうする。
なぜなら、 最上位ビットを見れば、その数は負数か、正数かどうかの判断がつくのでうれしいからである。

正の数の
最上位ビットは 0
負の数の
最上位ビットは 1

みたいに見分けが付きやすい。

n bit の2の補数表現には次の性質がある

* $2^{n}$ 種類の符号付き数を表せる
* 最大値は $2^{n-1} -1$
* 最小値は $-2^{n-1}$
* 正の数の最上位 bit は 0
* 負の数の最上位 bit は 1
* x から -x を得る方法は、
  最下位 bit から見ていく
  1 が出現するところまで見ていって、
  1 が出現したところ以降の bit を反転させる

例： 4bit 2進表現 0110 の負数は？
0110 を最下位 bit から見ていくと 2 bit 目が 1であるので、 3 bit 以降の bit を反転させると負数ができあがる。
つまり、 - 0110 = 1010

2の補数での和差の計算は、対象が正か負かを気にせずに計算できる。
つまり同じアルゴリズムで表現できる点が優れている。

例：4 bit 2進数での2の補数で (-2) + (-3) を考える
1110 + 1101 = 11011
オーバーフローを取り除くと 1011
つまり -5

つまり、ひとつの回路に算術演算と論理演算のすべてをまとめることができそう。
なぜなら、算術演算も論理演算を用いることで実現できる(はず)からである。
この回路は ALU (Arithmetric Logical Unit) と呼ばれる。

## ALU を構成するもの
* 加算回路
  * half adder: 2つの bit の和を求める
  * full adder: 3つの bit の和を求める
  * adder: 2つの n bit の和を求める
    * incrementer: ある n bit に対して1を加える
* 論理回路
  * 前章までに出てきた、 And, Or, Not, Mux(マルチプレクサ)

## Adder (加算器)
> コンピュータで行われる算術演算と論理演算はすべて、この ALU 回路によって行われる。

### half adder

```
HalfAdder
input: a,b
output: sum, carry
function:
sum = a + b の最下位 bit
carry = a + b の最上位 bit
```

### full adder
```
FullAdder
input: a,b,c
output: sum, carry
function:
sum = a + b + c の最下位 bit
carry = a + b + c の最上位 bit
```

### adder
メモリやレジスタなどの回路では、整数を表すために n bit の配列を用いる。
ここで、 n はコンピュータのプラットフォームによって異なる。

```
Add16
input: a[16],b[16]
output: out[16]
function:
out = a + b

2 の補数による加算。
オーバーフローは検出されず、無視される。
```

```
Inc16
input: in[16]
output: out[16]
function:
out = in + 1

2 の補数による加算。
オーバーフローは検出されず、無視される。
```

## ALU
> ここで述べる ALU は、Hack と呼ばれる特定のコンピュータプラットフォームだけ で使われる専用の回路である。
> Hack の ALU は、仕様で決められた関数である out = fi(x, y) を計算するように 設計されている。ここで、x と y は回路への 16 ビットの入力であり、out は 16 ビッ トの出力である。fi は算術演算または論理演算であり、全部で 18 種類の関数がある。 ALU に対して、どの関数を実行させるかを指定するには、制御ビット(control bits) と呼ばれる 6 ビットの入力ビットを用いる。

> 基本的な算術ができる汎用的な演算器。コンピュータによって実装が異なる。
> 掛け算・割り算などはここで実装しないが、OS側で実装する。
> OS と ALU がそれぞれどこの算術までカバーするかがキモ
[低レイヤﾁｮｯﾄﾜｶﾙ(nand2tetris/コンピュータシステムの理論と実装2章) - クソ雑魚エンジニアのメモ帳](https://morimori-kochan.hatenablog.com/entry/2019/01/13/122457)

ALU = 算術演算と論理演算を行う回路

* Mux は if 文っぽい動作をする

### ALU 回路の作り方のコツ
* zero をやって、 negative をする
  * x -> zx -> nx
  * y -> zy -> ny

* その次に、 f をやる

* 最後に、 no をやる

* 負判定は、 最上位ビットが1かどうかで行う And でできる

* 0判定は、 全体のビットが0かどうかで行う And でできる

最後のところでの陥りがちなエラー解消方法
> Can't connect gate's output pin to part: load ALU.hdl
[Chapter 2 - ALU - Can't connect gate's output pin to part](http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/ALU-Can-t-connect-gate-s-output-pin-to-part-td4026625.html)

* 出力先は複数書ける
> 出力先が1ビットならばあまり便利な場面が無いですが、複数ビットを出力する場合は部分的に別々に出力したり、別名をつけたりできます。

``` vhdl
And16(a=x, b=y, out[0..7]=aout, out[8..15]=bout, out=out, out=myout);
```

* 内部バスはスライス表記ができない
> 複数ビットを代入するような書き方をすると、勝手に複数ビットに対応したピン（＝内部バス）ができます。この内部バスは、スライス表記ができないようです。

``` vhdl
// inputとして定義したバスはスライス表記ができる
CHIP Or16Way {
  IN
    in[16];
  OUT
    out;
  PARTS:
  Or8Way(in=in[0..7], out=aout);
  Or8Way(in=in[8..15], out=bout);
  Or(a=aout, b=bout, out=out);
}
// ところが自分で定義した暗黙の内部バスはスライスできない
CHIP NotOr16Way {
  IN
    in[16];
  OUT
    out;
  PARTS:
  Not16(in=in, out=notin);
  Or8Way(in=notin[0..7], out=aout); //←エラー！
  Or8Way(in=notin[8..15], out=bout);
  Or(a=aout, b=bout, out=out);
}
対策としてはこんなふうに出力時に分岐すればよいようです。

// 出力時に別名をつければOK
CHIP NotOr16Way {
  IN
    in[16];
  OUT
    out;
  PARTS:
  Not16(in=in, out[0..7]=notin1, out[8..15]=notin2);
  Or8Way(in=notin1, out=aout);
  Or8Way(in=notin2, out=bout);
  Or(a=aout, b=bout, out=out);
}
```

何をするかはわかりやすかったし、実装は簡単にできるはず…だったが、
HDL の言語について把握できてなかったことがあって、めちゃ大変だった。
内部バスに対してスライス表記ができないことがわからなくて、ゼロ判定のところでだいぶ悩んだ。
HDL の言語仕様の把握ができてない。

# まとめ
前章で作成した And, Or, などの論理回路を用いて、 算術回路(半加算器、全加算器など) を実装し、
論理演算 + 算術演算を行える ALU の実装を行った。

## 成果物
* HalfAdder … 半加算器
* FullAdder … 全加算器
* Add16 … 16 進加算
* Inc16 … 16 進インクリメンタ
* ALU … 論理算術ゲート
