2019-04-29 23:17:31

# 順序回路
* 組み合わせ回路：時間に依存しない回路。入力値の組み合わせだけで値が決定するもの。論理演算、算術演算の回路など
* 順序回路：時間に依存する回路。状態を持てる回路

フリップフロップという順序回路を用いることで、記憶素子を構成できる。
記憶素子には同期、クロッキング、フィードバックなどが関係する

フリップフロップによってコンピュータで使われる記憶装置全ては実装される。

* 2値素子 (1bit のレジスタ)
* レジスタ (n bit のレジスタ)
* メモリ
* カウンタ
の回路があれば、コンピュータ全体を構築できる

* 本書では予め用意されてるプリミティブの DFF(data flip-flop) を使う
[https://ouj-cs.github.io/ouj-cs/yk/nand2tetris/chapter03_dff.html](https://ouj-cs.github.io/ouj-cs/yk/nand2tetris/chapter03_dff.html)

# メモリ回路
> 「記憶する」という行為は本質的に時間に依存する行為である。つまり、「前に記憶したものを今思い返す」という行為が記憶することの本質である。そのため、情報を記 憶するための回路を構築するには、時間の経過を表す方法を考案しなければならない。

## クロック
* 継続的にマスタクロックが送信する信号のこと。
この信号によって、時間経過を表現する。この信号はすべての順序回路に送られる。

> コンピュータでは継続的に変化する信号をマスタクロックが送信することで時間の経過を表現します。ハードウェアでの実装はオシレーター(発振回路)に基づくのが一般的です。オシレーターは0/1などのふたつのフェーズを絶え間なく行き来します。0の始まりから0の終わりまでを周期と呼ぶ。この1周期を単位時間としてモデル化されます。

## フリップフロップ (本書では DFF を用いる)
* 順序回路の基本要素である

簡単に言うと、DFF はクロックが進むまで待機して一つ前のタイムユニットの入力値を出力する回路

式で書くとこんな感じ
$$
out(t) = in(t-1)
$$

* フリップフロップを用いることで回路内にフィードバックループを作成することができる。

理由：
> 各クロック周期の始まりにおいて、ひとつ前のタイムユニットにおける入力の値が送信され、その入力値によって出力値が決定される。その他の 時間においては、DFF は“掛け金を閉めた(latched)”状態である。つまり、入力値 が変わっても、それによってすぐに出力値が変わらない、ということ

> コンピュータで状態を保つために用いられるハードウェア装置―― 2 値素子、レジスタ、RAM(random access memory)など――は、いずれもこの基本となる振る舞いによって形成される。

すべての DFF は同期している。
理由：
> プラットフォーム上でマスタクロックの信号をすべての DFF ゲートへ一斉に送信することで達成できる

### DFF の実装
``` hdl
回路名 DFF
入力 in
出力 out
関数 out(t)=in(t-1)
コメント このゲートは基本要素として使うため、実装する必要はない。
```

## レジスタ

$$
out(t) = out(t-1)
$$

を実現する

### 1bit レジスタ Bit (binary cell)
1 bit だけ記憶できるレジスタ

1 ビットのレジスタのことを、「ビット」または「2 値素子(binary cell)」と呼ぶ。

```
                  |
                 load
                  |
                 \/
-------in------>| \
                |  -----> dff --- out ----->
----out(t-1)--->| /                    |
|                                      |
---------------------------------------/
```

動作の説明

``` hdl
if load(t-1) then out(t) = in(t-1) else out(t) = out(t-1)
```

ロードビット ... レジスタに新しい値を保持させるか、レジスタの値をそのままにしておくかを決める bit のこと
* もしレジスタに新しい値を保持させたいならば、その新しい値を 入力 in に入れ、「読み込みビット」である load に 1 を設定すればよい。また、もし 内部の値をレジスタに保持させたいならば、load ビットを 0 にすればよい。

load(t-1) が false だったら、前回の値 `out(t-1)` を出力する
つまり、これは値をレジスタが記憶していると言える。

load(t-1) が true だったら、in(t-1) を出力する
つまり、これは値をレジスタが書き換えたと言える。

クロックの t-1 については深く考えずに、

* load が false (0) だったら、out は一定。つまり記憶されている
* load が true (1) だったら、 out は in の値に書き換わる
と思えば直感は正しい。

``` hdl
回路名 Bit
入力 in, load
出力 out
関数 If load(t-1) then out(t)=in(t-1)
        else out(t)=out(t-1)
```

実装レベルでは Mux は 0 だったら a, 1 だったら b が出力されるので
それぞれ
* a には dff の out をフィードバックループさせる
* b には dff in を入れてあげる

### w bit レジスタ
> 多ビットのレジスタは 1 ビットレジスタを必要な数だけそろえて、それらを配列上に並べて構築することができる

load bit は 1bit なのは変わらないことに注意

一般的に w は 16, 32, 64 などの数字が用いられる。

その多ビットの値を word と呼ぶ

``` hdl
回路名 Register
入力 in[16], load
出力 out[16]
関数 If load(t-1) then out(t)=in(t-1)
else out(t)=out(t-1) コメント 「=」は 16 ビットの演算である。
```

## メモリ
w bit レジスタが複数集まったもの + アドレス

並列にwビットレジスタが配置されている。

width ... 各 word の幅。つまり n bit レジスタの n に当たる。
size ... word の数。つまり、 n bit レジスタをいくつ RAM が持つかに当たる。
は決めておく必要がある。

RAM
> ランダムアクセスメモリの名前の由来は、ランダムに選ばれたワードに対して、そのワードが位置する場所に制限を受けることなく、書き込み/読み込みができることからです。メモリ内のワードは物理的な場所に関係なく同じ場所で直接アスセスできなければなりません。

周期ごとに、

* どのレジスタに対して（address）
* 読み込みか書き込みか（load）
* 入力値（in）
を入力として与える


``` hdl
回路名 RAMn // nとkについては以下の別表を参照 入力 in[16], address[k], load
出力 out[16]
関数 out(t)=RAM[address(t)](t)
        If load(t-1) then
           RAM[address(t-1)](t)=in(t-1)
コメント 「=」は 16 ビットの演算である。 Hackプラットフォームに必要なRAM回路
```

| 回路名 | n     | k    |
| :---   | :---  | :--- |
| RAM8   | 8     | 3    |
| RAM64  | 64    | 6    |
| RAM512 | 512   | 9    |
| RAM4K  | 4096  | 12   |
| RAM16K | 16384 | 14   |

例えば、
> RAM64 メモリから特定のアドレスを選択するためには、6 ビットのアドレスを 用いる。この 6 ビットアドレスを、たとえば、xxxyyy と表記したとすると、上位の xxx ビットは RAM8 回路のひとつを選択するために用い、下位の yyy ビットは、そ の選択した RAM8 内から特定のレジスタを選択するために用いる。

## カウンタ
> 一般的な CPU にはプログラムカウンタ(program counter)が含まれ、このプログラムカウンタの出力は次に実行されるプログラム演算のアドレスとして解釈される。

カウンタは順序回路であり、タイムユニットが進むごとに、

$$
out(t) = out(t − 1) + c
$$

となるように、ある整数の値が加算される。ここで、c には通常 1 が用いられる。

``` hdl
回路名 PC // 16ビットカウンタ
入力 in[16], inc, load, reset 出力 out[16]
関数 If reset(t-1) then out(t)=0
     else if load(t-1) then out(t)=in(t-1)
     else if inc(t-1) then out(t)=out(t-1)+1
     else out(t)=out(t-1)
コメント 「=」は 16 ビットの代入演算である。 「+」は 16 ビットの算術加算である。
```

## 時間
順序回路内のフィードバックループによって

* 「状態を保つ(メモリなど)」
* 「状態を操作する(カウンタなど)」
が実現される。

* 組み合わせ回路... 時間という概念はモデル化されていないため、フィードバックループを導入するには問題がある。なぜなら、出力は入力だけに依存するが、もし入力がその回路自身の出力に依存するとしたら、出力 も出力自身に依存することになり、矛盾が生じるからである。

* 順序回路... 出力を同じ回路の入力に送信することに対しては、問題は生じない。なぜなら、DFF は「時間遅延」という性質を内在するからである。つまり、DFF によって、時刻 t の出力ではなく、時刻 t − 1 の出力がその回路自身に影響を与える、 ということである。この性質のおかげで、制御不能の「データレース」と呼ばれる現 象――組み合わせ回路でフィードバックループに伴う現象――を防止できる。

# まとめ
レジスタ、 RAM8 を作るのはそんなに難しくなかった。
RAM8 を利用して RAM64 を作るのは結構面倒だった。 RAM64 のアドレスは、6bit。 RAM8 のアドレスは 3bit。そのギャップをどう埋めるかがポイント。アドレスを分割すればいける。
あと、カウンタの実装はフィードバックループを利用するんだけど、これがむずかった。クロック(時間)を考えるのがポイントだったけど、ちゃんと分かっているのかちょっと不安。

## 成果物
* レジスタ: Bit, Register
* RAM: RAM8, RAM16, RAM64, RAM512, RAM4K, RAM16K
* プログラムカウンタ: PC

# 参考
* [nand2tetrisを実装する(4)第3章 順序回路-後編- - セキュリティ・キャンプ キャンパー育成枠の活動録](https://genkai-io.hatenablog.jp/entry/2018/12/06/190000)
